{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"True Adaptive Music Wiki","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the wiki for the Minecraft mod, True Adaptive Music!</p> <p>Join the official discord here for help with using the mod, and to access the community's collection of MusicPacks!</p>"},{"location":"#what-is-true-adaptive-music","title":"What is True Adaptive Music?","text":"<p>TrueAdaptiveMusic adds a whole new dimension to Minecraft's music system! Instead of tracks being randomly played and loosely grouped together, they can now be played in specific situations. Music can either be triggered to play while a certain in-game condition is met or on specific in-game events. You can even bring along any audio files you want to play! How is this all managed? Something called Music Packs! Music Packs (similar to resource and data packs) contain all of the logic that determines when music should play, and any new audio you want to bring into the game. These packs can then be shared with other users so they can jam along!</p> <p>If you have any issues/suggestions for this doc or the mod itself, please create an issue ticket in the Github linked above.</p> <p>If you are new to the mod and want to learn more, start here.</p>"},{"location":"FFmpeg%20Support/","title":"FFmpeg Support","text":"<p>Some Music Packs may contain audio file types that are non-ogg (e.g. wav or mp3), which are not supported by Minecraft's sound engine. If a pack contains a file like this and you haven't gone through this tutorial yet, you will see this in the pack selection screen:</p> <p> The pack will still be usable, but any non-ogg files will be skipped. To make these files work you need to install FFmpeg.</p>"},{"location":"FFmpeg%20Support/#how-to-install-and-set-up-ffmpeg","title":"How to install and set up FFmpeg","text":""},{"location":"FFmpeg%20Support/#step-1-open-powershell-as-administrator","title":"Step 1: Open Powershell as Administrator","text":"<p>First open the windows search, search for powershell and click \"Open as Administrator\". Hit yes for any following dialogs. </p>"},{"location":"FFmpeg%20Support/#step-2-install-ffmpeg","title":"Step 2: Install FFmpeg","text":"<p>Now run the command <code>winget install \"FFmpeg (Essentials Build)\"</code>. Just type it into the prompt and hit enter. </p>"},{"location":"FFmpeg%20Support/#step-3-restart-your-pc","title":"Step 3: Restart Your PC","text":"<p>Finally restart your PC and you should be good to go!</p>"},{"location":"Advanced%20Topics/Advanced%20Topics/","title":"Advanced Topics","text":"<p>Welcome to the Advanced Topics page for Music Pack creation!</p> <p>Modded Predicates and Events</p> <p>Supported Input Widget Types</p> <p>TypedIdentifiers</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/","title":"Modded Predicates and Events","text":"<p>Warning</p> <p>This is an advanced topic that requires at least some programming experience in Java/Kotlin or other similar high-level languages. Modding experience (particularly in Minecraft) is also recommended. I assume here that you already know how to create a mod for Minecraft. If you are completely new and want to learn how to create a mod, follow the fabric tutorial here as well as using this page to set up your development environment. Kotlin is required to implement modded events/predicates.</p> <p>As of version 1.2, TrueAdaptiveMusic now allows the creation of custom predicate and event types! This allows for a whole new level of Music Pack creation as predicates and events can be made that are specific to other mods. One great example is with the Cobblemon mod. This fantastic mod adds the world of Pok\u00e9mon to Minecraft, and one staple of Pok\u00e9mon is the battles! There's just one problem, the battles have absolutely no music. What if we could make a new predicate type that specifically is true when the user is in a battle? Then we could specify some battle music to play when it's true! Let's dive in.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#creating-modded-predicates-and-events","title":"Creating Modded Predicates and Events","text":"<p>Warning</p> <p>As of mod version 1.3, modded predicate and event types must be registered during mod initialization, or they will not show up in-game or be recognized. As an additional consequence, the getTypeName functions should no longer be implemented. See Registering Your Predicate or Event Type for how to register a modded type.</p> <p>Implementing either modded predicates or events (or both) requires creating a \"bridge mod\". That is, a mod that \"bridges\" the functionalities of two mods. If you are the creator of the mod you want to make the bridge for, you could also just follow the steps below as an integration (similar to adding ModMenu support) directly into your mod.</p> <p>First, make a new mod (or open up your existing mod project if you are the mod owner). I personally recommend using the Minecraft Development plugin with Intellij as it makes the boilerplate steps very easy. However you do it, you'll want to make a mod for the Minecraft version you are using and for fabric.</p> <p>Once your environment is loaded, you'll want to get the jar files for both your mod (if you are making a bridge mod) and the TrueAdaptiveMusic mod which can be found on the TrueAdaptiveMusic releases page. Once you have the required jars, throw them into your mod project's base directory.</p> <p>Once you've done that, your project should look something like this: </p> <p>Finally you'll need to add these as dependencies in your gradle build. Open your \"build.gradle.kts\" file, go to the <code>dependencies</code> task and add a <code>modImplementation</code> directive for each jar like below: </p> <p>Finally make sure to download sources for gradle and you're good to go! In IntelliJ this can be done by opening the gradle window and clicking the download icon: </p> <p>After that task finishes, you're ready to create your custom predicates or events! If you are creating an event, I would still recommend reading the predicate tutorial first, as events are similar but more complicated.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#creating-modded-predicates","title":"Creating Modded Predicates","text":"<p>Creating modded predicates is definitely the easier of the two. To start, create a new class under the client section of your mod. For the sake of convention, please name your class with \"Predicate\" at the end. Here we'll name it PokeBattlePredicate, since we want music to play when we are in a pokemon battle.</p> <p></p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#implementing-the-api","title":"Implementing the API","text":"<p>After creating the class, have it extend the MusicPredicate abstract class from the TrueAdaptiveMusic API, which you will need to import (your IDE should be able to help you with this). If the class can't be found, try restarting your IDE or downloading sources again as shown above.</p> <pre><code>class PokeBattlePredicate: MusicPredicate() {\n}\n</code></pre> <p>Now implement the missing virtual function implementation, <code>test(MinecraftClient)</code>: <pre><code>class PokeBattlePredicate: MusicPredicate() {\n    override fun test(client: MinecraftClient): Boolean {\n        return false\n    }\n}\n</code></pre></p> <p>This is the function that decides whether your predicate should evaluate as true or false at each tick of the game. Make this just return false for now.</p> <p>Before implementing that though, first some extra housekeeping needs to be done. This next part is required or your predicate will not work.</p> <p>Add a companion object to your class implementing the <code>MusicPredicateCompanion&lt;T&gt;</code> interface, where <code>T</code> is your predicate class. You are required to override <code>fromJson</code> or your predicate will not work.</p> <pre><code>companion object: MusicPredicateCompanion&lt;PokeBattlePredicate&gt; {\n    override fun fromJson(json: JsonObject): MusicPredicate {\n        return PokeBattlePredicate()\n    }\n}\n</code></pre> <p>For You can keep <code>fromJson</code> as is for now, but you'll want to revisit if you decide to add additional parameters to your type as described later.</p> <p>For now, try launching the game in your dev environment. Create a new pack, click to add a new child node, and you should now see your new type in this type list! </p> <p>Now close the game. It's time to make the predicate type actually work!</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#implementing-the-test-function","title":"Implementing the test Function","text":"<p>This section depends entirely on what your predicate type is actually for. So for this section I'll just show you how the <code>poke_battle</code> predicate is implemented, as it is very simple. Luckily, Cobblemon supplies a publicly available singleton object <code>CobblemonClient</code> that contains state information for the client. Inside the object is a reference to the battle. This gives us a trivial solution, just check if <code>battle</code> is null. If it isn't, return true, otherwise false. This is the resulting function:</p> <pre><code>override fun test(client: MinecraftClient): Boolean {\n    return CobblemonClient.battle != null\n}\n</code></pre> <p>Not all mods will allow such a simple solution though. You may need to use a combination of mixins and accessmodifiers to properly implement. If you run into any issues, feel free to ask for help in the <code>#modding-help</code> section of the discord (requires the Modder role). If you want to add parameters to your predicate to allow for further customization of your type, head over here.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#creating-modded-events","title":"Creating Modded Events","text":"<p>Modded event types are more complicated to implement than predicate types, so I would recommend reading that first. What makes them more complicated is that they will almost always require a mixin to implement. I say almost because if you are making event types as an integration to a mod you own rather than as a bridge, you can just invoke the event manually from your mod code. If you don't already know how to create mixins, follow this wiki.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#implementing-the-api_1","title":"Implementing the API","text":"<p>First let's create the event class itself. This is very similar to creating a new predicate type. First create a class implementing the MusicEvent abstract class from the TrueAdaptiveMusic API, following the convention of the class name staring with \"On\" and ending with \"Event\". For this example, we'll be creating an event called <code>OnPokeBattleVictoryEvent</code> which should trigger when the user wins a pokemon battle:</p> <pre><code>class OnPokeBattleVictoryEvent: MusicEvent() {\n}\n</code></pre> <p>Additionally we'll need to add a companion implementing the <code>MusicEventCompanion&lt;T&gt;</code> interface, where T is your event class. And it is also required you override <code>fromJson</code> or your event will not work. <pre><code>companion object: MusicEventCompanion&lt;OnPokeBattleVictoryEvent&gt; {\n    override fun fromJson(json: JsonObject): MusicEvent {\n        return OnPokeBattleVictoryEvent()\n    }\n}\n</code></pre></p> <p>Unlike predicates, we don't have a <code>test</code> function to implement. This is because events aren't evaluated every tick, instead they are manually triggered by a callback invocation. This callback can be accessed via <code>MusicEvent.invokeMusicEvent</code> as shown below.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#creating-the-mixin","title":"Creating the Mixin","text":"<p>Now we'll need to make a mixin to trigger the event. If you are the creator of the mod are making the event for, you can just invoke the callback seen below directly in your mod code.</p> <p>This particular mixin was a bit painful to work around, but here was the result: <pre><code>@Mixin(BattleMessagePane::class)\nclass OnPokeBattleVictoryEventMixin {\n    @Inject(\n        method = [\"addEntry(Lcom/cobblemon/mod/common/client/gui/battle/widgets/BattleMessagePane\\$BattleMessageLine;)I\"],\n        at = [At(\"HEAD\")])\n    fun addEntry(entry: BattleMessagePane.BattleMessageLine, ci: CallbackInfoReturnable&lt;Int&gt;) {\n        val userWonString =  battleLang(\"win\", MinecraftClient.getInstance().player?.displayName ?: return)\n            .string\n\n        if (entry.line.getInternalString() == userWonString) {\n            MusicEvent.invokeMusicEvent(TAMClient.INSTANCE.getEventRegistry().get(OnDayStartEvent.class))\n        }\n    }\n}\n</code></pre></p> <p>From what I have found, since the mixin target is a Kotlin class, it is best to write the mixin itself in Kotlin as well. This is of course against the standard practice and Java should be used for mixins whenever possible.</p> <p>As you can see, we are calling <code>MusicEvent.invokeMusicEvent</code> and passing in the type name of our event. This informs the internal music manager to play the event's music. That's really all there is to creating a modded event, but what if you only want the event to play under the conditions based on parameters of an individual event instance? For that you'll first want to add some parameters to your event type, and write a <code>validate</code> implementation as show below.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#implementing-the-validate-function","title":"Implementing the validate Function","text":"<p>If you do add parameters to the event type, you'll want to override the <code>validate</code> member function (outisde of the companion object). This function is called just before your event is invoked to add an additional layer of logic to determine whether the event should occur. The parameters that are passed into <code>validate</code> are determined at the call site of the event invocation (i.e. in the mixin). For example you might have a setup like this (<code>stringToTest</code> is an event parameter as described here): OnSomethingEvent.kt<pre><code>class OnSomethingEvent(private val stringToTest: String): MusicEvent() {\n    override fun validate(vararg eventArgs: Any?): Boolean {\n        val someCondition = eventArgs[0] as? Boolean ?: return false\n        val someString = eventArgs[1] as? String ?: return false\n        return someCondition &amp;&amp; someString == stringToTest\n    }\n\n    ...\n}\n</code></pre> The above code takes in some arguments from the event invoker and interprets them to validate whether the event instance should occur.</p> <p>Then at the event call site: SomeMixin.java<pre><code>...\nMusicEvent.invokeMusicEvent(TAMClient.INSTANCE.getEventRegistry().get(OnDayStartEvent.class), someCondition, someString)\n...\n</code></pre> We pass in the type name like usual, but then include the parameters matching the types used in the <code>validate</code> definition.</p> <p>Now the event will only trigger if the validate function says so after the event has been invoked by the mixin.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#adding-parameters-to-your-predicate-or-event-type","title":"Adding Parameters to Your Predicate or Event Type","text":"<p>Just like some vanilla predicates have additional parameters for each instance to specify, modded predicates and events can have the same. For both events and predicates, you must add your parameters a very specific way. In both cases the first thing you need to do is declare your paramaters as <code>private val</code>. For example, we'll use the <code>BiomePredicate</code>: <pre><code>class BiomePredicate(private val biomes: List&lt;BiomeIdentifier&gt;): MusicPredicate()\n</code></pre> Here we want any instance of the <code>BiomePredicate</code> to store a list of biome identifiers (<code>biomes</code>) to match with what the current biome the player is in.</p> <p>In order for your predicate/event parameters to work, you need to fulfill two conditions for each parameter:</p> <ol> <li>They must be declared in the constructor parameter list.</li> <li>They must be one of the types supported by the UI, otherwise it will be impossible to use the UI to create an instance of the type. For a list of supported types, go here.</li> </ol> <p>We also want to make sure the predicate can be serialized properly, so inside the companion, we need to override the <code>fromJson</code> member function: <pre><code>override fun fromJson(json: JsonObject): BiomePredicate {\n    return BiomePredicate(\n        if (JsonHelper.hasArray(json, \"id\"))\n            JsonHelper.getArray(json, \"id\").map { element -&gt; BiomeIdentifier(element.asString) }\n        else\n            listOf(BiomeIdentifier(JsonHelper.getString(json, \"id\"))))\n}\n</code></pre></p> <p>Now for predicates, the parameters you created can be used in your <code>test</code> function. For events, they can be used in the <code>validate</code> function.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#registering-your-predicate-or-event-type","title":"Registering Your Predicate or Event Type","text":"<p>Once your type is ready for use, you need to register it, or it will not be recognized in-game. To do this, you just need to call the TAMClient helper function <code>registerPredicate</code> for predicates or <code>registerEvent</code> for events. Below is an excerpt from the TrueAdaptiveMusic client initializer for the vanilla types: <pre><code>...\nTAMClient.registerPredicate(\"boss\", BossPredicate::class)\nTAMClient.registerPredicate(\"combat\", CombatPredicate::class)\nTAMClient.registerPredicate(\"day\", DayTimePredicate::class)\n...\nTAMClient.registerEvent(\"on_advancement_get\", OnAdvancementGetEvent::class)\nTAMClient.registerEvent(\"on_boss_defeat\", OnBossDefeatEvent::class)\nTAMClient.registerEvent(\"on_day_start\", OnDayStartEvent::class)\n...\n</code></pre> The first argument will determine the name of your predicate as it is serialized in the music pack rules and should conform to the snake_case standard, as well as the on_ prefix for event types. The second argument is the runtime object representing the class, which can be retrieved with ::class in kotlin or .class in java.</p>"},{"location":"Advanced%20Topics/Modded%20Predicates%20and%20Events/#additional-note","title":"Additional Note","text":"<p>If a music pack contains events/predicates that the client doesn't have the bridge mod for, the pack will still load but those triggers will never occur.</p>"},{"location":"Advanced%20Topics/Supported%20Input%20Widget%20Types/","title":"Supported Input Widget Types","text":"<p>Some predicate/event types have instance parameters declared in their constructor parameter list. In order for these to be able to be set properly via the Music Pack creation UI, they must conform to one of the supported types by the input widget factory. In the future, we plan to allow the user to create their own widget types, as well as filling out more basic types. Here is a complete list of these types and what the resulting widget will be:</p> Parameter Type Resulting Widget Int Text input widget only allowing integers UInt Text input widget only allowing non-negative integers Boolean Checkbox widget Enum (or subtype of) Dropdown of all values belonging to the enum List Multi-Select dropdown of all values belonging to the enum TypedIdentifier (or subtype of) Dropdown of all identifiers within that type. See TypedIdentifiers List Multi-Select dropdown of all identifiers within that type. See TypedIdentifiers"},{"location":"Advanced%20Topics/TypedIdentifiers/","title":"Typed Identifiers","text":"<p>The True Adaptive Music API provides some convenience types for handling registry sets of identifiers. This is to help the widget factory filter down all identifiers to a specific registry. All of these inherit directly from the <code>TypedIdentifier</code> type which inherits from the <code>Identifier</code> type native to Minecraft, and contain a <code>getRegistryIds</code> helper function to get all the current registered identifiers under a give scope. Here is a list of current <code>TypedIdentifier</code> subtypes, each corresponding to the registry of the same name:</p> <ul> <li>BiomeIdentifier</li> <li>DimensionIdentifier</li> <li>EntityTypeIdentifier</li> <li>StructureIdentifier</li> <li>StructureSetIdentifier</li> </ul> <p>More will be added in later versions of TrueAdaptiveMusic. Also be aware that some identifier types hail from dynamic registries, meaning they will be empty until a world is loaded.</p>"},{"location":"Music%20Packs/Events/","title":"Events","text":"<p>In a Music Pack, Events are one-shot music that is played when some in-game event occurs, for example the player getting an advancement, or waking up from a bed. When an event plays, any ongoing music will quiet down until the event music finishes.</p>"},{"location":"Music%20Packs/Events/#the-event-pool","title":"The Event Pool","text":"<p>Events are tied to predicate nodes, in that each predicate node contains a list of events. When that predicate node is chosen, the event pool (the list of events that are able to be triggered) is updated. The current event pool is always the aggregate of the current predicate node's events and those of it's ancestors all the way up to <code>root</code>. If there is a conflict between two events between parent and child, the child will always take priority.</p>"},{"location":"Music%20Packs/Events/#vanilla-types","title":"Vanilla Types","text":"<p>Info</p> <p>Identifier types are explained here.</p> Type Name Parameters Triggered When... on_advancement_get None The player gets an advancement toast on_boss_defeat bosses: [EntityTypeIdentifier] A boss is defeated nearby on_day_start None The ticks this day hits 0 on_death None The player encounters the death screen on_enter_predicate None The active predicate becomes the predicate that this event is part of on_join_world None The player's world gets set on_night_start None The ticks this day hits 13000 on_recipe_unlock None The player gets a recipe unlock toast on_tutorial_popup None The player gets a tutorial toast on_wake_up None The player's sleep chat closes without the \"Leave Bed\" button pressed <p>Feel free to request new vanilla types. More types for integration with other mods can be added with modded events.</p>"},{"location":"Music%20Packs/Music%20Pack%20Structure/","title":"MusicPack Structure","text":"<p>Below is the structure of a music pack: Pack Name \u251c\u2500 assets/ \u2502  \u2514\u2500 Audio Files \u251c\u2500 meta.json (optional) \u2514\u2500 rules.json  </p> <p>Packs can be directories or .zip, but must follow the exact structure above.</p>"},{"location":"Music%20Packs/Music%20Pack%20Structure/#assets","title":"assets/","text":"<p>The assets folder should contain all the audio files you plan to use in your modpack. If you are only using music that's loaded into minecraft (vanilla or modded), this directory should be empty.</p> <p>By default, the only supported audio file type is .ogg. In order to use packs that utilize other audio types, follow this guide.</p>"},{"location":"Music%20Packs/Music%20Pack%20Structure/#metajson","title":"meta.json","text":"<p>This file is optional but can contain any extra data to display your pack. Right now there is only one field this stores, the description of the pack, and there is currently no way to set this within the UI, so if you really want to set it, you'll have to go into the meta.json generated with your mod and change it yourself.</p> meta.json<pre><code>{\n    \"description\": \"{Your music pack description text here}\"\n}\n</code></pre>"},{"location":"Music%20Packs/Music%20Pack%20Structure/#rulesjson","title":"rules.json","text":"<p>This is the most important file in the pack, as it contains all of the logic that tells the mod when to play certain music. This json file defines the PredicateTree structure, which is a tree made of nodes that each represent a condition where certain music should be played. For a list of conditions (predicate types), see the Predicates section. Additionally, each node in the tree contains a list of events that can trigger one-shot music playback when certain events occur. Check out Events for more info.</p> <p>The structure of the rules is recursive, with one object called a PredicateNode. A Predicate Node contains the Predicate Type, a list of music to play (either by sound event ID or by filename in the assets/ folder), any events associated with it, and a list of all of its child nodes. This is visited in more depth within the How is a Predicate Node Chosen section of the Predicates page.</p> <p>For example:</p> rules.json<pre><code>{\n    \"type\": \"root\", //(1)!\n    \"musicPath\": [\n        \"minecraft:music.overworld.meadow\",\n        \"cool_song.ogg\",\n        \"cooler_song.mp3\"\n    ], //(2)!\n    \"children\": [ //(3)!\n        {\n            \"type\": \"dimension\",\n            \"id\": \"minecraft:overworld\", //(4)!\n            \"musicPath\": [], //(5)!\n            \"events\": []\n        }\n    ],\n    \"events\": [ //(6)!\n        {\n            \"type\": \"on_death\",\n            \"musicPath\": [\n                \"death_music.mp3\"\n            ]\n        }\n    ]\n}\n</code></pre> <ol> <li>The top-level node is always of type \"root\"</li> <li>You can use audio files from assets/ and minecraft sound events that start with \"music.\". Even non-ogg files are supported if you have FFmpeg installed.</li> <li>And now this node's children, which themselves have the same structure</li> <li>Some predicates require extra parameters, such as the 'id' field here. This predicate will only be true when the player is in the overworld dimension</li> <li>Since music path is empty, no music will play when this predicate is true</li> <li>If the player dies, \"death_music.mp3\" will play. Events are passed down to the children of the predicate node they are defined in, so events defined under root will always when that event occurs unless overriden by a child.</li> </ol> <p>Learn more about events and predicates</p>"},{"location":"Music%20Packs/Optional%20Node%20Parameters/","title":"Optional Node Parameters","text":"<p>Any predicate node can have some optional parameters set. Here are the current available parameters:</p> Parameter Name Type Description trackDelay UInt Adds a set number of seconds of delay after a track finishes within a predicate node trackDelayNoise UInt Adds a random amount +- between 0 and this value to trackDelay with a floor of 0"},{"location":"Music%20Packs/Predicates/","title":"Predicates","text":"<p>In a Music Pack, Predicates are the driving force for continuous music being played. That is, when a predicate is selected by the music manager, the music stored within it is what is played. If the current selected predicate changes, the music changes with it.</p>"},{"location":"Music%20Packs/Predicates/#how-is-a-predicate-node-chosen","title":"How is a Predicate Node Chosen","text":"<p>Every tick of the game, there is a music manager that traverses this tree and decides what music should be played. It will always pick the music belonging to the first satisfied node with no children that are satisfied. If a node has no children and it satisfied, that is the node that will be chosen. This is important as it allows for sectioning off different types of music for different scenarios (we'll dive deeper into this very soon). Another consequence of this is that we must have a root node that is always considered satisfied, as that allows us to define music (or no music) to play when no other predicate nodes are satisfied. This is why you are hearing music right now if you are following this tutorial in order. There are no other predicates to satisfy so it is defaulting to play music defined in the root predicate node. This behavior allows sectioning of music as it allows for something like the following scenario:</p>"},{"location":"Music%20Packs/Predicates/#an-example","title":"An Example","text":"<p>Let's say you want to make a very simple music pack that adds combat music to minecraft. You could just add a \"combat\" node under the root node and put some combat music in that node and you're done... but what if you wanted the music to be different based on what dimension you are in? You could then create a dimension node as a child of the combat node. Since only one dimension predicate will be satisfied (you can't be in multiple dimensions at once), it will only play the combat music that you set for that dimension. You could also add some wandering music to each dimension node for some nice atmosphere in between combat by adding another dimension node as the child of root and giving it some music.</p>"},{"location":"Music%20Packs/Predicates/#vanilla-types","title":"Vanilla Types","text":"<p>Info</p> <p>Identifier types are explained here.</p> Type Name Parameters True When... biome id: [BiomeIdentifier] The player is in any biome within the <code>id</code> list boss id: [EntityTypeIdentifier] There is a boss bar on the player's screen for any of the entity types within the <code>id</code> list combat None A mob is within sufficient range of the player and is attacking them day None The ticks for the day is between 0 and 12999 inclusive dimension id: [DimensionIdentifier] The player is in any dimension within the <code>id</code> list first_day None The total world ticks is between 0 and 24000 inclusive (within one minecraft day) game_mode gameMode: GameMode (Builtin Enum) The player's gamemode is equal to the specified <code>gameMode</code> health healthType: Enum('value', 'percentage'), direction: Enum('Greater', 'GreaterOrEqual', 'Lesser', 'LesserOrEqual'), health: Int The player's health <code>value</code> or <code>percentage</code> meets the <code>direction</code> requirements with <code>health</code> height above: Boolean, y: Int The player's y coordinate is <code>above</code>/<code>below</code> the <code>y</code> value specified moon_phase moonPhase: Enum('New', 'Full') The world's moon phase matches that given by <code>moonPhase</code> specfied night None The ticks for the day is between 13000 and 23999 inclusive pillager_raid None The player is currently in a pillager raid riding entities: [EntityTypeIdentifier] The entity that the player is riding is of a type within the <code>entities</code> list status statusEffects: [StatusEffectIdentifier] The player currently has any status effect specified within the <code>statusEffects</code> list structure id: [StructureIdentifier] The player is within the maximum bounds of all features assigned to any of the structure types within the <code>id</code> list structure_set id: [StructureSetIdentifier] Same as <code>structure</code>, but for sets of structure types rather than individual structure types. title_screen None The player is not in a world weather weatherType: Enum('Clear', 'Rain', 'Thunder') The weather is the type specified by <code>weatherType</code> <p>Feel free to request new vanilla types. More types for integration with other mods can be added with modded predicates.</p>"},{"location":"Other%20Stuff/Converting%20Audio%20Files/","title":"Converting Audio Files (Made Easy!)","text":"<p>Info</p> <p>As of True Adaptive Music version 1.2 you no longer need to convert audio files to .ogg, but you will need to setup ffmpeg for playback to work.</p>"},{"location":"Other%20Stuff/Converting%20Audio%20Files/#converting-with-audacity-the-easy-way","title":"Converting with Audacity (the easy way)","text":"<p>Since converter websites are sketchy beyond hell as there is nothing stopping them from stuffing any data they want within a file you get there, we'll discuss a much better alternative. Enter the wonderful DAW app Audacity, which you can download here. Once you have gone through the installation, start it up.</p> <p>There are many ways to batch convert files with Audacity, one of the most cumbersome ways I consistently saw online involved macros (it ain't that deep). With Audacity open, you'll be met with this window:</p> <p></p> <p>From here, you can simply drag and drop all your files right into the audacity window, and you'll see every file laid out in its own track:</p> <p></p> <p>Now it's just a matter of batch exporting these files as .mp3, which you can do by going to File -&gt; Export Audio.</p> <p></p> <p>This will open the export window. From here you will want to make sure you have the \"Multiple Files\" option selected, and also hit the \"Browse...\" button if you want to save the files to a more convenient place than it already shows.</p> <p></p> <p>Then hit \"Export\" and you should see each file get converted in order. Once that is done, go to the destination that was selected and pick up your fresh .mp3 files. You're now ready to move on to placing those files in the right place!</p>"},{"location":"Quick%20Start/For%20Creators/","title":"For Creators","text":""},{"location":"Quick%20Start/For%20Creators/#quick-start-for-music-pack-creators","title":"Quick Start: For Music Pack Creators","text":"<p>Warning</p> <p>Music Pack Creating/Editing is only available for Minecraft versions 1.20+. Any Music Pack made in any version will still be compatible with other versions of Minecraft.</p>"},{"location":"Quick%20Start/For%20Creators/#creating-new-a-music-pack","title":"Creating new a Music Pack","text":"<p>So you want to create a Music Pack? First of all, thank you! If you have any creations you are proud of by the end of this I encourage you to share in the community discord! Now, let's get started.</p> <p>Start by clicking the \"Create a new music pack\" Button at the top left. This will bring up the MusicPack naming screen. Type in a name and hit \"Accept\" to continue, which will open the pack editing screen:</p> <p></p>"},{"location":"Quick%20Start/For%20Creators/#saving-without-exporting-to-zip","title":"Saving Without Exporting to Zip","text":"<p>Before we do anything, a quick note on saving. When you opened this editing page, a folder was immediately created called {yourpackname}.new in the trueadaptivemusicpacks folder. From now on, every single action you take will be saved real-time inside this folder, provided you hit the small save button in the right \"Predicate View\" panel. This way you don't need to worry about leaving this menu or game crashes. This also offers a great way to incrementally test your pack since you don't need to \"Save and Zip\" your pack to use it. It will still show up in the main page. Don't believe me? Hit escape to return to the previous page now.</p> <p></p> <p>Your new pack should be sitting there all fancy, and it will auto reload as you exit the pack screen for testing. If you are curious what an empty pack looks like, you can hit the \"Open Pack Folder\" button to take a look. Otherwise click on your pack if you haven't already, and you will see a \"Edit Pack\" button show up at the bottom left. Click that to return to the editing screen.</p> <p>This silence is deafening isn't it, let's go ahead and get some tunes playing. Click on the text labeled \"root\" at the top left.</p> <p></p> <p>Then click the \"Select a track\" button on the right. To open a dropdown of all available music. If you don't have any mods that add music (and you didn't skip ahead and add your own assets), you should just see a list of all the vanilla Minecraft music expressed as Sound Events. Go ahead and pick one, then hit the \"Save\" button just under it, we'll be here a while.</p> <p>Phew! The silence was really getting to me, thanks for that. Now that we have some easy listening, we can talk about the edit screen.</p> <p>As you can see, the edit screen is seperated into two panels, let's talk about the left first, the Pack Structure panel.</p>"},{"location":"Quick%20Start/For%20Creators/#pack-structure-panel","title":"Pack Structure Panel","text":"<p>The pack structure defines the structural logic of your music pack, specifically when certain music should play. Every music pack has a tree-like structure, with the top level only holding the \"root\" node in that tree. Every node in this tree represents a predicate. A predicate is just a condition in which certain music can be played, and can be one of many different types. For a list of all types, you can visit the Predicate Types page. Every node in the tree has a depth, denoted by how indented the node is on screen, and the \"child\" node of another node will have 1 more than the depth of its parent. Also within each node is a list of songs to play when that node is chosen (this is what we chose when setting music on the root node). For an explanation of how predicate nodes are chosen each tick of the game, go here.</p>"},{"location":"Quick%20Start/For%20Creators/#adding-assets","title":"Adding Assets","text":"<p>Now that we know the basics, we can start thinking about how we want to theme the pack. If you want to just try out making a basic pack with vanilla sound events only you can skip down to Creating the Pack (Finally). If you are making a pack right now (if you aren't why are you here), you might already have some ideas for how you want to theme your pack. If you do, now would be a good time to gather some assets (external audio files) for your pack. Now I do work for the FBI, CIA, NATO, specifically the Chicago police that patrol O-Block and the Illuminati, so I won't tell you that there are many great ways to get good music from other games to use for your music pack. And I definitely won't tell you that the Internet Archive is a great way to find some. By default Minecraft only supports .ogg files, but lucky you! As of True Adaptive Music 1.2 basically any audio file type is supported, as long as you setup ffmpeg first. If you (for some reason) want to stick with .ogg, then you can follow this guide for converting any files to .ogg easily. Once you have some files ready, continue on.</p>"},{"location":"Quick%20Start/For%20Creators/#where-to-place-your-assets","title":"Where to Place Your Assets","text":"<p>This part is easy as pie, just hit the \"Open Assets\" folder in the edit screen and drag your files into the folder that opens. If that somehow doesn't work, you can just head to the folder yourself, which is in the same directory as the resourcepacks folder in your Minecraft root installation. Find {your_music_pack_name}.new, open it, and drag your files into the <code>assets/</code> folder.</p> <p></p>"},{"location":"Quick%20Start/For%20Creators/#creating-the-pack-finally","title":"Creating the Pack (Finally)","text":"<p>Now let's get into actually modifying the structural logic of the pack. You can add a child to any node just by clicking the \"+ Add\" button under it, which you can do to the button under \"root\" right now. Once you do, you'll see that the Predicate View panel on the right updated to allow you to create the node. Note that changes made here are not in-effect until the save button at the bottom of the right panel is clicked. Be aware can't create certain predicates from here if you opened this page without being loaded into a world, since some parameters for certain predicate types rely on accessing a dynamic registry, which is empty when not loaded into a world. Pick any that don't have this restriction such as day/night/title_screen. Now you can simply pick a song, or some songs, to play from the \"Music Choice\" dropdown. If you select a song but want to remove it, just click on it in the list under the dropdown. Once you're done, you can hit \"Save\" under the Music Choice, and this will commit the change to the actual music pack folder. If you change your mind about any property of a node, you can just click on it and modify any of the same settings (just make sure to hit \"Save\" again after). You can even go into a world to test this now as long as your \".new\" pack is selected from the pack selection screen. As you'll see in this next section, you'll want to join a world in a second anyway ;)</p> <p></p>"},{"location":"Quick%20Start/For%20Creators/#other-required-predicate-parameters","title":"Other Required Predicate Parameters","text":"<p>With simple predicate types like title_screen, day, or night, the predicate itself is binary (it's either day or it isn't). For other predicate types though, it isn't so simple. Let's examine the dimension predicate for example. First make sure you are loaded into a world, lest you fall victim to the aformentioned red save button. Once you are loaded in, make your way back to the predicate menu and press the \"+ Add\" button on any node, or click any existing node (other than root) to modify it. Set the predicate type to dimension and you'll see a new \"dimension\" parameter.</p> <p></p> <p>This is another dropdown that allows you to select an identifier for the dimension you want for the predicate. Here you can select any dimension you want, and then select music that can play in that dimension. As said before, you could create child nodes of this dimension node as well to have specific music for day/night/combat/etc.</p>"},{"location":"Quick%20Start/For%20Creators/#optional-predicate-node-parameters","title":"Optional Predicate Node Parameters","text":"<p>As of True Adaptive Music version 1.2, there are some some extra parameters tied to each node in the \"Predicate View\" panel. These are optional and explained here.</p>"},{"location":"Quick%20Start/For%20Creators/#moving-predicate-nodes","title":"Moving Predicate Nodes","text":"<p>As of True Adaptive Music verison 1.2, you now move predicate nodes by simply clicking and dragging from the selected node. An arrow will show exactly where your node will go when you release the button. You can't move any nodes above root and you also can't move a node to be a child of itself.</p>"},{"location":"Quick%20Start/For%20Creators/#events","title":"Events","text":"<p>As of True Adaptive Music version 1.2, there is support for \"events\" as well. There is more information on them here, but consider them like one-shot music triggers rather than a continuous condition in which music plays. To add an event, select any predicate and click the \"+ Add\" button. If there is an existing event there</p> <p></p> <p>Now the Predicate View Panel moves to the left side and the new Event View Panel appears. Here you can customize the event the same way you do with predicates. The music you pick here will be played specifically when the event occurs, assuming the node or it's children are selected.</p> <p></p> <p>Once you are done creating/editing the event, you can either hit the \"Save\" button in the panel or hit \"Back\" at the top of the panel to discard your changes to the event. Make sure to finally hit \"Save\" in the Predicate View Panel to save your event changes to the pack.</p>"},{"location":"Quick%20Start/For%20Creators/#exporting-the-pack","title":"Exporting the Pack","text":"<p>That's really all there is to it. You can head to Other Functionalities for any other features in the editor, but you now know everything you need to make a Music Pack... except... well exporting. Luckily this is super simple, just hit the \"Save and Zip\" button at the top left:</p> <p></p> <p>This will delete your \".new\" directory and replace it with a zipped up version in the same pack directory so you can send it around easily. Zip files can also be loaded the same way as directories, so you don't need to unzip it to use it. If you decide you want to edit your pack again, just select your \".zip\" pack in the pack selection screen and select \"Edit Pack\" again. This will create another \".new\" directory pack and keep your \".zip\" as a backup. Selecting \"Save and Zip\" on the \".new\" pack will overwrite your existing \".zip\" pack.</p>"},{"location":"Quick%20Start/For%20Creators/#outro","title":"Outro","text":"<p>Congrats on making it through this \"quick\" start. Once again, please let us know if there is anything you want to see improved with this wiki! You can now head to the MusicPacks section at the top left of this wiki for more info on the inner workings of MusicPacks! If you want to take a look at some more advanced capabilities for Music Pack creation such as adding custom predicate and event types, also take a look at the advanced topics section.</p>"},{"location":"Quick%20Start/For%20Everyone/","title":"For Everyone (Start Here)","text":""},{"location":"Quick%20Start/For%20Everyone/#quick-start-for-everyone","title":"Quick Start: For Everyone","text":"<p>First start up Minecraft with the mod loaded and you will now notice a new button at the bottom of the Music &amp; Sound Options menu: </p> <p>Clicking this will take you to the main menu for True Adaptive Music: </p> <p>But you don't have any Music Packs yet (probably)! Join the community discord to check out the community's creations!</p> <p>Once you have a pack, head over to Quick Start: For Users. If you are want to make a Music Pack yourself and already have used the mod before, you can skip over to Quick Start: For Creators.</p>"},{"location":"Quick%20Start/For%20Users/","title":"For Users","text":""},{"location":"Quick%20Start/For%20Users/#quick-start-for-musicpack-users","title":"Quick Start: For MusicPack Users","text":"<p>Hit \"Open Pack Folder\" to reveal the folder where Music Packs are stored. This will be the trueadaptivemusicpacks/ folder, which is generated inside of your Minecraft's installation root (the same folder where you see resourcepacks) the first time you start up Minecraft with the mod.</p> <p>Throw your .zip or directory file into this folder, then hit \"Refresh\", and voila! You'll see it show up on this page.</p> <p></p> <p>Now just click on your newly loaded pack and (assuming there is custom title screen or root music), you should immediately notice the difference! Have Fun </p> <p>If you'd like to create a Music Pack, head on over to Quick Start: For Creators</p>"}]}